---
title: "Analysis of BeatAML [ONC0115/ONC0124]{.tangerine}"
subtitle: "Immuno-Oncology: T cell engagers"
abstract: "This analysis aims to assess the association between gene expression and clinical metadata for the BeatAML dataset"
author: 
  - name: Jason Cosgrove
    affiliations:
      - id: id_team
        name: Computational Medicine Team
date: today
format: 
  servier-html:
    code-tools: false
    number-sections: false
---


## Set-up

```{r, echo=FALSE, results='hide', message=FALSE, warning=FALSE}


knitr::opts_knit$set(root.dir = "/home/EW96_FR5/projects/ImmunoOncology/ONC0115_TCEs/Tcell_engagers")

#load packages used in the analysis

library(tidyverse)
library(bbcVerse)
library(readxl)
library(knitr)
library(scales)
library(glue)
library(ggtext)
library(withr)
library(DT)
library(gt)
library(janitor)
library(writexl)
library(broad.depmap)
library(circlize)
library(ComplexHeatmap)
library(ggsignif)
library(rstatix)
library(conflicted)
library(FSA)
conflicts_prefer(dplyr::filter)

theme_set(theme_bbc())

set.seed(42)


```


#### helper methods
```{r, warning=FALSE}


# Define the generic plotting function
scatter_plot <- function(df, x_var, y_var, x_label, y_label, plot_title) {
  p <- ggplot(df, aes_string(x = x_var, y = y_var)) +
    geom_point(alpha = 0.2, color = "blue", position = position_jitter(width = 0.2)) +  # Scatter plot with jitter
    geom_smooth(method = "lm", se = FALSE, color = "red") +  # Trend line (linear model) without confidence interval
    theme_minimal() +  # Use a minimal theme for a cleaner look
    labs(
      x = x_label,
      y = y_label,
      title = plot_title
    ) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for better readability
      plot.title = element_text(hjust = 0.5)  # Center the title
    )
  
  return(p)
}


plot_heatmap <- function(beat_metadata,genes,ann_colors, clustering = TRUE){

  expr <- beat_metadata[,genes]
  
  # Scale expression data by gene
  expr_scaled <- scale(expr, scale = TRUE)
  
  rownames(beat_metadata) <- beat_metadata$sample_id
  rownames(expr_scaled) <- beat_metadata$sample_id
  
  
  # Set color functions
  col_fun_expr <- colorRamp2(c(-3, 0, 3), c("navy", "white", "red"))

  # Heatmap annotations
  ha <- HeatmapAnnotation(
    df = beat_metadata[, c("tissue", "DiseaseStatus", "FAB", "BoneMarrowBlastsPct")],
   # MICA_TPM = anno_barplot(beat_metadata[, "MICA"], bar_width = 0.8, height = unit(2, "cm")),
    col = ann_colors,
    annotation_name_gp = gpar(fontface = "bold")
  )
  
  rha <- rowAnnotation(
    tpm = anno_boxplot(
      beat_metadata[,genes], height = unit(4, "cm"),
      gp = gpar(fill = 'dodgerblue'), extend = 0.05, outline = FALSE, box_width = 0.6,
      pch = 1, size = unit(2, "mm"), axis = TRUE
    )
  )
  
  if(clustering == TRUE){
  # Heatmap for monocyte-related genes
  mono <- Heatmap(
    t(expr_scaled[rownames(beat_metadata),]),
    name = "Z-score",
    show_column_names = FALSE,
    col = col_fun_expr,
    cluster_rows = TRUE,
    row_names_gp = gpar(fontface = "bold"),
    clustering_distance_columns = "euclidean",
    clustering_method_columns = "ward.D2",
    clustering_distance_rows = "euclidean",
    clustering_method_rows = "ward.D2",
    top_annotation = ha,
    right_annotation = rha,
    column_split = beat_metadata$tissue,
    cluster_column_slices = FALSE )
  }else{
      mono <- Heatmap(
    t(expr_scaled[rownames(beat_metadata),]),
    name = "Z-score",
    show_column_names = FALSE,
    col = col_fun_expr,
    cluster_rows = FALSE,
    row_names_gp = gpar(fontface = "bold"),
    clustering_distance_columns = "euclidean",
    clustering_method_columns = "ward.D2",
    #clustering_distance_rows = "euclidean",
    #clustering_method_rows = "ward.D2",
    top_annotation = ha,
    right_annotation = rha,
    column_split = beat_metadata$tissue,
    cluster_column_slices = FALSE)
  }
  
    return(mono)
    
}





set_heatmap_colors <- function(){
# Set annotation colors for heatmaps
var1 <- setNames(c("blueviolet", "darkgoldenrod1"), levels(beat_metadata$tissue))
var2 <- setNames(c("cyan2", "brown2", "ghostwhite", "lightskyblue", "dodgerblue3", "darkgreen", "#FF00DB"), levels(beat_metadata$DiseaseStatus))
var3 <- setNames(c("#0092FF", "#FFDB00", "#49FF00", "#FF0000", "white", "#0092FF", "#4900FF", "#FF00DB", "green4", "#49FF00", "#0092FF", "#4900FF", "#0092FF", "#4900FF"), levels(beat_metadata$FAB))
var4 <- colorRamp2(c(0, 50, 100), c("white", "green2", "green4"))
  
ann_colors <- list(
    tissue = var1,
    DiseaseStatus = var2,
    FAB = var3,
    BoneMarrowBlastsPct = var4
  )

  return(ann_colors)
}


plot_gene_expression <- function(df, genes, parameter) {
  # Replace empty strings with NA in the parameter column
  df[[parameter]][df[[parameter]] == ""] <- NA
  
  # Filter out rows with NA in the parameter column
  df_tmp <- df[complete.cases(df[[parameter]]), ]
  
  # Loop through each gene and create a boxplot with jitter
  for (gene in genes) {
    df_tmp$logexprs <- df_tmp[[gene]]
    p <- ggplot(df_tmp, aes_string(x = paste0("factor(", parameter, ")"), y = "logexprs")) +
      geom_boxplot(outlier.size = 0) +  # Use `outlier.size = 0` to hide default boxplot outliers
      geom_jitter(width = 0.2, alpha = 0.2, color = "dark red") +  # Jitter points with transparency
      theme_minimal() +  # Use a minimal theme for a cleaner look
      labs(
        x = parameter,
        y = "log2(tpm + 1)",
        title = gene
      ) +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for better readability
        plot.title = element_text(hjust = 0.5)  # Center the title
      )
    
    print(p)
  }
}









plot_gene_expression2 <- function(df, gene, parameter) {
  # Replace empty strings with NA in the parameter column
  df[[parameter]][df[[parameter]] == ""] <- NA
  
  # Filter out rows with NA in the parameter column
  df_tmp <- df[complete.cases(df[[parameter]]), ]
  
  # Prepare data for plotting
  df_tmp$logexprs <- df_tmp[[gene]]
  
  # Check the number of unique groups
  unique_groups <- unique(df_tmp[[parameter]])
  num_groups <- length(unique_groups)
  
  if (num_groups == 2) {
    # Perform Wilcoxon rank-sum test
    wilcox_test <- wilcox.test(logexprs ~ as.factor(df_tmp[[parameter]]), data = df_tmp)
    p_value <- wilcox_test$p.value
    
    # Define comparisons for ggsignif
    comparison <- list(unique(as.character(df_tmp[[parameter]])))
    
    # Create the plot
    p <- ggplot(df_tmp, aes_string(x = paste0("factor(", parameter, ")"), y = "logexprs")) +
      geom_boxplot(outlier.size = 0) +  # Use `outlier.size = 0` to hide default boxplot outliers
      geom_jitter(width = 0.2, alpha = 0.2, color = "dark red") +  # Jitter points with transparency
      theme_minimal() +  # Use a minimal theme for a cleaner look
      labs(
        x = parameter,
        y = "log2(tpm + 1)",
        title = paste0(gene, " (Wilcoxon p = ", format.pval(p_value, digits = 3), ")")
      ) +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for better readability
        plot.title = element_text(hjust = 0.5)  # Center the title
      ) +
      geom_signif(
        comparisons = comparison,
        annotations = paste0("p = ", format.pval(p_value, digits = 3)),
        y_position = max(df_tmp$logexprs) * 1.05,
        tip_length = 0.01,
        textsize = 3
      )
    
  } else {
    # Perform Kruskal-Wallis test
    kruskal_test <- kruskal.test(logexprs ~ factor(df_tmp[[parameter]]), data = df_tmp)
    p_value <- kruskal_test$p.value
    
    # Perform Dunn's test for pairwise comparisons
    dunn_test <- dunnTest(logexprs ~ as.factor(df_tmp[[parameter]]), data = df_tmp, method = "bh")
    dunn_results <- dunn_test$res
    
    # Prepare comparisons for ggsignif
    significant_comparisons <- lapply(which(dunn_results$P.adj < 0.05), function(i) {
      comparison <- strsplit(dunn_results$Comparison[i], " - ")[[1]]
      return(c(comparison[1], comparison[2]))
    })
    
    # Create the plot
    p <- ggplot(df_tmp, aes_string(x = paste0("factor(", parameter, ")"), y = "logexprs")) +
      geom_boxplot(outlier.size = 0) +  # Use `outlier.size = 0` to hide default boxplot outliers
      geom_jitter(width = 0.2, alpha = 0.2, color = "dark red") +  # Jitter points with transparency
      theme_minimal() +  # Use a minimal theme for a cleaner look
      labs(
        x = parameter,
        y = "log2(tpm + 1)",
        title = paste0(gene, " (Kruskal-Wallis p = ", format.pval(p_value, digits = 3), ")")
      ) +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for better readability
        plot.title = element_text(hjust = 0.5)  # Center the title
      )
    
    # Add significant comparisons significance annotations, if any
    if (length(significant_comparisons) > 0) {
      p <- p + geom_signif(
        comparisons = significant_comparisons,
        map_signif_level = TRUE,
        textsize = 3,
        y_position = max(df_tmp$logexprs) + seq_len(length(significant_comparisons)) * 0.7
      )
    }
  }
  
  # Print the plot
  print(p)
}



corr_plot <- function(df,gene){
  df$BoneMarrowBlastsPct[df$BoneMarrowBlastsPct == ""] <- NA

    df_tmp <- df[complete.cases(df$BoneMarrowBlastsPct), ]
    
   df_tmp$logexprs <- df_tmp[[gene]]
  
    # Calculate Spearman's correlation
  correlation <- cor.test(df_tmp$BoneMarrowBlastsPct, df_tmp$logexprs, method = "spearman")
  spearman_rho <- correlation$estimate
  spearman_p <- correlation$p.value

# Create the plot
  p <- ggplot(df_tmp, aes_string(x = 'BoneMarrowBlastsPct', y = 'logexprs')) +
    geom_point(alpha = 0.2, color = "blue", position = position_jitter(width = 0.2)) +  # Scatter plot with jitter
    geom_smooth(method = "lm", se = FALSE, color = "red") +  # Trend line (linear model) without confidence interval
    theme_minimal() +  # Use a minimal theme for a cleaner look
    labs(
      x = "BM blast %",
      y = "log2(tpm + 1)",
      title = gene
    ) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for better readability
      plot.title = element_text(hjust = 0.5)  # Center the title
    ) +
    annotate("text", x = Inf, y = Inf, label = paste0("Spearman's rho = ", round(spearman_rho, 3), "   p =", format.pval(spearman_p, digits = 3)), 
             hjust = 1.7, vjust = 2, size = 5, color = "black")
  
  
  print(p)

  
}


```

#### Define genes of interest
```{r, warning=FALSE}

tce <- c("CD4","BTN2A1","BTN3A1", "BTN3A2", "BTN3A3", "MICA","MICB", "ULBP1", "ULBP2", "ULBP3", "RAET1E", "RAET1G", "RAET1L","ADAM9", "ADAM10", "ADAM15", "ADAM17", "MMP9", "MMP14", "PDIA6", "PDIA2", "PDIA3", "TXNDC5", "PDIA4", "ERP44", "ERP29", "NRROS","CTSG","WT1","PRAME",
         'SIGLEC6','RXFP4','TAS2R46','TAS2R43','TAS2R30','TAS2R13',
         "CD33","SIGLEC6","FLT3","IL3RA",
         "CD3D", "CD3E", "TRDC", "TRGC1", "TRGC2")

tce_filtered <- c("CD4","BTN2A1","BTN3A1", "BTN3A2", "BTN3A3", "MICA","MICB", "ULBP1", "ULBP2", "ULBP3", "RAET1E", "RAET1G", "RAET1L","ADAM9", "ADAM10", "ADAM15", "ADAM17", "MMP9", "MMP14", "PDIA6", "PDIA2", "PDIA3", "TXNDC5", "PDIA4", "ERP44", "ERP29", "NRROS","CTSG","WT1","PRAME",
         'SIGLEC6','RXFP4','TAS2R46','TAS2R43','TAS2R30','TAS2R13',
         "CD33","SIGLEC6","FLT3","IL3RA",
         "CD3D", "CD3E", "TRDC", "TRGC1", "TRGC2")

mic <- c("MICA","MICB", "ULBP1", "ULBP2", "ULBP3", "RAET1E", "RAET1G", "RAET1L","ADAM9", "ADAM10", "ADAM15", "ADAM17", "MMP9", "MMP14", "PDIA6", "PDIA2", "PDIA3", "TXNDC5", "PDIA4", "ERP44", "ERP29" )

tis <- c("CD274", "CXCL9", "CXCL10", "IDO1", "HLA-DRA", "STAT1", "CD8A", "GZMA", "CCL5", "NKG7", "PSMB10", "HLA-E", "LAG3", "CD276", "TIGIT", "PDCD1LG2", "CMKLR1", "HLA-F")

gdT <-  c("CD3D", "CD3E", "TRDC", "TRGC1", "TRGC2")

all_genes <- unique(c(tce, tis, gdT, mic))

```

#### Import the dataset
```{r, warning=FALSE}
bbcUtils::buckets_mount(yaml_path = "buckets.yaml")
eset_aml <- readRDS("~/projects/ImmunoOncology/ONC0115_TCEs/Tcell_engagers/GCP/BEATAML/Beat_AML/Raw/Beat_AML_B38-TPM.Rds")

beatAML_Etienne <- readRDS("~/projects/ImmunoOncology/ONC0115_TCEs/Tcell_engagers/inputs/beatAML_deconvoluted.rds")

df_aml <-
  eset_aml %>%
  filter_features_from_values("gene_name", all_genes) %>%
  join_samples() %>%
  select(sample_id = sample_id, type = disease_state,
         age = age_years, any_of(all_genes)) %>%
  mutate(across(any_of(tce), ~ log2(. + 1)))
  

beat_metadata_tmp <- merge(pData(eset_aml), beatAML_Etienne$clinical, by = "sample_id")

beat_metadata <- merge(beat_metadata_tmp, df_aml, by = "sample_id")

rm(eset_aml)

bbcUtils::buckets_umount(yaml_path = "buckets.yaml")

```

#### Data preprocessing

```{r, message=FALSE, warning=FALSE}

  # Convert metadata columns to appropriate data types
beat_metadata <- beat_metadata %>%
    mutate(
      tissue = as.factor(tissue),
      DiseaseStatus = as.factor(DiseaseStatus),
      FAB = as.factor(`FAB[Classification]`),
      BoneMarrowBlastsPct = as.numeric(`BoneMarrowBlasts[%]`)
    )

beat_metadata <- beat_metadata %>%
    filter(!is.na(tpm_scaling_factor))

ann_colors <- set_heatmap_colors() 

```

```{r, message=FALSE, warning=FALSE}

boxplot <- function(gene, dataset) {
  
  df <- switch (dataset,
                "MET500" = df_met,
                "TCGA" = df_tcga_tumor,
                "GTEx" = df_gtex,
                "BeatAML" = beat_metadata)
  
  
  df <- df %>%
    filter(DiseaseStatus %in% 
             c('primary','secondary', 
               'recurrent','remission') ) %>%
  mutate(DiseaseStatus = droplevels(DiseaseStatus))
  
  # Checking the number of observations in each DiseaseStatus group
filtered_df <- df %>%
  group_by(DiseaseStatus) %>%
  filter(n() > 10) %>%  # keeping groups with more than 1 observation
  ungroup()

# Perform Kruskal-Wallis test
kruskal_test_result <- filtered_df %>%
  kruskal_test(as.formula(paste(gene, "~ DiseaseStatus")))

# Pairwise comparison
pairwise_test_result <- filtered_df %>%
  wilcox_test(as.formula(paste(gene, "~ DiseaseStatus"))) %>%
  adjust_pvalue(method = "BH") %>%
  add_significance()

# Extracting comparisons for use in geom_signif
comparisons <- pairwise_test_result %>%
  #filter(p.adj.signif != "ns") %>%  # Only significant pairwise comparisons
  select(group1, group2) %>%
  arrange(group1, group2)



# Adding significance to the plot
significance_plot <- filtered_df %>%
  mutate(type = fct_reorder(DiseaseStatus, .data[[gene]])) %>%
  ggplot() +
  aes(x = DiseaseStatus, y = .data[[gene]], color = DiseaseStatus) +
  geom_boxplot(alpha = 0, outliers = FALSE, show.legend = FALSE, color = "grey30") +
  geom_jitter(alpha = 0.1, width = 0.2) +
  labs(x = NULL, y = "log2(TPM + 1)", title = str_c(gene, " expression in ", dataset)) +
  theme(legend.position = "none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  geom_signif(comparisons = as.list(comparisons), 
              map_signif_level = TRUE, 
              y_position = seq(1.2, by = 0.2, 
                               length.out = nrow(comparisons)) + max(df[[gene]]))

 print(significance_plot)
}


```

## Data Overview: Expression Patterns for Different Clinical Parameters


### Expression across the entire dataset

```{r, eval = TRUE}

# Create df_long, remove NAs
df_long <- beat_metadata[,c("sample_id",tce)] %>%
  pivot_longer(cols = -sample_id, names_to = "Gene", values_to = "Expression") %>%
  filter(!is.na(Expression))  # Remove NAs

# Reorder 'Gene' factor levels by mean expression
df_long <- df_long %>%
  group_by(Gene) %>%
  mutate(mean_expression = mean(Expression)) %>%
  ungroup() %>%
  arrange(mean_expression)  # Arrange genes by mean expression

df_long$Gene <- factor(df_long$Gene, levels = unique(df_long$Gene))

# Create the plot
ggplot(df_long, aes(x = Gene, y = Expression, color = Gene)) +
  geom_boxplot(show.legend = FALSE, outliers.shape = NA) +  # Boxplot for each gene, hide outliers
  geom_jitter(alpha = 0.01, width = 0.2, show.legend = FALSE) +
  labs(x = NULL, y = "Expression Level", title = "Gene Expression Boxplots") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1))  # Rotate x-axis labels




```


### Expression in Bone Marrow vs Peripheral Blood

::: {.panel-tabset}




```{r childs1, eval = TRUE}
#| results: asis
#| echo: false

  df <- beat_metadata 

for (i in c(tce)) {
  
  var <- "tissue"
  a <- knit_child("quarto/targets2.qmd", 
                  quiet = T)
  cat(a, sep = "\n")
}

```

::: 



### Expression across disease states
::: {.panel-tabset}


```{r childs13, eval = TRUE}
#| results: asis
#| echo: false

  df <- beat_metadata %>%
    filter(DiseaseStatus %in% 
             c('primary','secondary', 
               'recurrent','remission') ) %>%
  mutate(DiseaseStatus = droplevels(DiseaseStatus))

for (i in c(tce)) {
  
  var <- "DiseaseStatus"
  a <- knit_child("quarto/targets2.qmd", 
                  quiet = T)
  cat(a, sep = "\n")
}

```

::: 

### Blast %

::: {.panel-tabset}



```{r childs199, eval = TRUE}
#| results: asis
#| echo: false

df <- beat_metadata %>%
  mutate(BoneMarrowBlastsPct = na_if(BoneMarrowBlastsPct, "")) %>%  # Replace empty strings with NA
  filter(!is.na(BoneMarrowBlastsPct))  # Filter out rows with NA in BoneMarrowBlastsPct


for (i in c(tce)) {
  
  correlation_plot <- TRUE
  a <- knit_child("quarto/targets2.qmd", 
                  quiet = T)
  cat(a, sep = "\n")
}

```


:::

### FAB classification


::: {.panel-tabset}
```{r childs13, eval = TRUE}
#| results: asis
#| echo: false

  df <- beat_metadata %>%
    filter(FAB != "" ) 

for (i in c(tce)) {
  
  var <- "FAB"
  a <- knit_child("quarto/targets2.qmd", 
                  quiet = T)
  cat(a, sep = "\n")
}

```
:::


### Risk Factor (ELN 2017)


::: {.panel-tabset}

```{r childs134, eval = TRUE}
#| results: asis
#| echo: false

beat_metadata$ELN <- beat_metadata$`RiskCategory[ELN2017]`

  df <- beat_metadata %>%
    filter(ELN %in% c("intermediate","favorable","adverse") ) 

for (i in c(tce)) {
  
  var <- "ELN"
  a <- knit_child("quarto/targets2.qmd", 
                  quiet = T)
  cat(a, sep = "\n")
}

```
:::

## Demographic Parameters


### Expression vs Age at Diagnosis

::: {.panel-tabset}


```{r childs154, eval = TRUE}
#| results: asis
#| echo: false

beat_metadata$AGE <- beat_metadata$`AgeAtDiagnosisRange[years]`

  df <- beat_metadata %>%
    filter(AGE != "" ) 

for (i in c(tce)) {
  
  var <- "AGE"
  a <- knit_child("quarto/targets2.qmd", 
                  quiet = T)
  cat(a, sep = "\n")
}

```


:::


### Gender

::: {.panel-tabset}


```{r childs164, eval = TRUE}
#| results: asis
#| echo: false

beat_metadata$GENDER <- beat_metadata$`Gender[inferred]`

  df <- beat_metadata %>%
    filter(GENDER %in% c("female","male")) 

for (i in c(tce)) {
  
  var <- "GENDER"
  a <- knit_child("quarto/targets2.qmd", 
                  quiet = T)
  cat(a, sep = "\n")
}

```

:::



## Data Overview: Heatmap Visualisations

::: {.panel-tabset}


### Whole Cohort
```{r, message=FALSE, warning=FALSE}
#| echo: false
#| global: true
#| message: false
#| fig-height: 14
#| fig-width: 18
#| column: screen-inset-right

p <- plot_heatmap(beat_metadata, tce, ann_colors, clustering = TRUE)

draw(p)


p <- plot_heatmap(beat_metadata, tce, ann_colors, clustering = FALSE)

draw(p)

```





### Primary and Secondary BM
```{r,  message=FALSE, warning=FALSE}
#| echo: false
#| global: true
#| message: false
#| fig-height: 14
#| fig-width: 18
#| column: screen-inset-right

beat_metadata_prim=beat_metadata %>%
  filter(DiseaseStatus %in% c("primary","second primary", "secondary")) %>%
  filter(tissue=="bone marrow")

p <- plot_heatmap(beat_metadata_prim, tce,ann_colors, clustering = TRUE)

draw(p)

p <- plot_heatmap(beat_metadata_prim, tce,ann_colors, clustering = FALSE)

draw(p)

```


### Recurrent BM
```{r,  message=FALSE, warning=FALSE}
#| echo: false
#| global: true
#| message: false
#| fig-height: 14
#| fig-width: 18
#| column: screen-inset-right

beat_metadata_rec=beat_metadata %>%
  filter(DiseaseStatus %in% c("recurrent","recurrent;secondary")) %>%
  filter(tissue=="bone marrow")


p <- plot_heatmap(beat_metadata_rec,tce,ann_colors,clustering = TRUE)

draw(p)

p <- plot_heatmap(beat_metadata_rec,tce,ann_colors, clustering = FALSE)

draw(p)

```

### Remission BM
```{r,  message=FALSE, warning=FALSE}
#| echo: false
#| global: true
#| message: false
#| fig-height: 14
#| fig-width: 18
#| column: screen-inset-right

beat_metadata_rem=beat_metadata %>%
  filter(DiseaseStatus %in% c( "remission")) %>%
  filter(tissue=="bone marrow")


tce_tmp <- tce[tce != 'RAET1L']

p <- plot_heatmap(beat_metadata_rem, tce_tmp,ann_colors, clustering = TRUE)

draw(p)

p <- plot_heatmap(beat_metadata_rem, tce,ann_colors, clustering = FALSE)

draw(p)


```

:::




## Mutations

```{r, warning=FALSE}

mutations <- grep("MutationStatus",colnames(beat_metadata),value = T)

result <- beat_metadata %>%
  select(all_of(mutations)) %>%
  summarise_all(~sum(. != ""))

#only keep mutations where we have results for at least 10 patients. 
mutations_filtered <- names(result[which(result > 10)])

```



```{r childs, eval = TRUE}
#| results: asis
#| echo: false

df <- beat_metadata

for (i in c(mutations_filtered)) {
  
  mut <- i
  
  df[,mut][df[[mut]] == ""] <- NA

  df_tmp <- df[complete.cases(df[[mut]]), ]

  if(length(unique(df_tmp[[mut]])) > 1){

    a <- knit_child("quarto/plot_mutation_expression.qmd", 
                    quiet = T)
    cat(a, sep = "\n")
  
  }
}
```

## Gene Signatures

```{r, warning=FALSE}

#calculate TIS score
beat_metadata$TIS_sig <- rowMeans(beat_metadata[,tis])

beat_metadata$gdT_sig <- rowMeans(beat_metadata[,gdT])

beat_metadata$MICAB_sig <- rowMeans(beat_metadata[,mic])

```


### Heatmaps

```{r, warning=FALSE}
#| echo: false
#| global: true
#| message: false
#| fig-height: 14
#| fig-width: 18
#| column: screen-inset-right

plot_heatmap_sigs <- function(beat_metadata,genes,ann_colors){
    
    expr <- beat_metadata[,genes]
    
    # Scale expression data
    expr_scaled <- scale(expr, scale = TRUE)
    
    rownames(beat_metadata) <- beat_metadata$sample_id
    rownames(expr_scaled) <- beat_metadata$sample_id
    
    
    # Set color functions
    col_fun_expr <- colorRamp2(c(-3, 0, 3), c("navy", "white", "red"))
    
    # Heatmap annotations
    ha <- HeatmapAnnotation(
        df = beat_metadata[, c("tissue", "DiseaseStatus", "FAB", "BoneMarrowBlastsPct")],
        # MICA_TPM = anno_barplot(beat_metadata[, "MICA"], bar_width = 0.8, height = unit(2, "cm")),
        col = ann_colors,
        annotation_name_gp = gpar(fontface = "bold")
    )
    
    rha <- rowAnnotation(
        tpm = anno_boxplot(
            beat_metadata[,genes], height = unit(4, "cm"),
            gp = gpar(fill = 'dodgerblue'), extend = 0.05, outline = FALSE, box_width = 0.6,
            pch = 1, size = unit(2, "mm"), axis = TRUE
        )
    )
    
    # Heatmap for monocyte-related genes
    mono <- Heatmap(
        t(expr_scaled[rownames(beat_metadata),]),
        name = "Z-score",
        show_column_names = FALSE,
        col = col_fun_expr,
        cluster_rows = FALSE,
        row_names_gp = gpar(fontface = "bold"),
        clustering_distance_columns = "euclidean",
        clustering_method_columns = "ward.D2",
        #clustering_distance_rows = "euclidean",
        #clustering_method_rows = "ward.D2",
        top_annotation = ha,
        right_annotation = rha,
        column_split = beat_metadata$tissue,
        cluster_column_slices = FALSE
    )
    
    return(mono)
    
}

sigs <- c("TIS_sig","gdT_sig","MICAB_sig")
p <- plot_heatmap_sigs(beat_metadata, sigs,ann_colors)

draw(p)



```




### Box Plots

::: {.panel-tabset}

### Disease Status
```{r, warning=FALSE}

plot_gene_expression(beat_metadata, sigs, "DiseaseStatus")


```

### ELN
```{r, warning=FALSE}

plot_gene_expression(beat_metadata, sigs, "ELN")


```

### FAB
```{r, warning=FALSE}

plot_gene_expression(beat_metadata, sigs, "FAB")

```

:::


### ScatterPlots
```{r, warning=FALSE}


# Example usage:
# scatter_plot(df_tmp, "BoneMarrowBlastsPct", "logexprs", "BM blast %", "log2(tpm + 1)", gene)



for(sig in sigs){
  
  for(gene in tce[1:6]){
    p <- scatter_plot(beat_metadata, sig, gene, sig, "log2(tpm + 1)", gene)
    
    print(p)
    
  }
}
```




## Benchmarking of gdT genes versus TRUST4 quantification of gdT frequencies
```{r, eval = FALSE}
#load tcga
#COAD, ESCA, READ, STAD, LAML
bbcUtils::buckets_mount(yaml_path = "buckets.yaml")

eset_tcga <- read_rds("GCP/TCGA/TCGA_B38_GC33-TPM.Rds")

df_tcga <-
  eset_tcga %>%
  filter_features_from_values("GeneName", tce) %>%
  join_samples() %>%
  select(id = samples_id, type = Tumor.Type,
         tumor_or_normal = Tumor.Or.Normal, any_of(tce)) %>%
  mutate(across(any_of(tce), ~ log2(. + 1)))
  

bbcUtils::buckets_umount(yaml_path = "buckets.yaml")


df_tcga_coad <-
  df_tcga %>% 
  filter(type == "COAD")

#read in all of the .tsvs, merge and have the id as a column



```


### Read in and merge all of the trust4 files for COAD
```{r, eval = FALSE}
# Set the folder path where your .tsv files are located
folder_path <- "TRUST4/COAD"

# List all .tsv files in the folder
file_list <- list.files(path = folder_path, pattern = "*.tsv", full.names = TRUE)

read_and_add_id <- function(file_path) {
  # Extract the file name without extension
  file_name <- basename(file_path)
  file_name_no_ext <- gsub("\\.tsv$", "", file_name)
  
  # Extract the id (portion before the first underscore)
  id <- unlist(strsplit(file_name_no_ext, "_"))[1]
  
  # Read the .tsv file, setting all columns as characters to avoid type conflicts
  data <- read_tsv(file_path, col_types = cols(.default = "c"))
  
  # Add the 'id' column
  data$id <- id
  
  return(data)
}

# Apply the function to all .tsv files and combine them into one dataframe
T4_data <- lapply(file_list, read_and_add_id) %>%
  bind_rows()

T4_data$gene <- gsub("\\*.*","", T4_data$V)
T4_data$type <- ifelse(grepl("TRA|TRB", T4_data$gene), "abT", "gdT") 
T4_data$count <- as.numeric(T4_data$`#count`)

# count the number of reads by type 
jT_count <- T4_data %>% group_by(type,id) %>%
  summarise(readsC = sum(count), .groups='drop') 
# add meta data

count <- jT_count %>% filter(type == "gdT")





df_tcga_coad <- df_tcga %>%
  filter(id %in% T4_data$id) %>%
  select(id, TRDC, TRGC1, TRGC2) %>%
  mutate(gdT = TRDC + TRGC1 + TRGC2) %>%
  mutate(gdT_mean = rowMeans(select(., TRDC, TRGC1, TRGC2), na.rm = TRUE))
  
#iterate over T4_data, for each sample calculate the sum of the gdT genes

merged_data <- merge(df_tcga_coad, T4_data, by = "id")

merged_data2 <- merge(df_tcga_coad, count, by = "id")

#now do the same one for the amount of gdT genes in each. hmm not sure this is a fair comparison would want to sum over all of the gdT
ggplot(merged_data  %>% filter(grepl("TRD|TRG", gene)), aes(x = id, y = log(count))) +
    geom_boxplot() +
  theme_bw()+
  labs(title = "Boxplot of cell count of TRD/G genes (TRUST4) by sample", x = "sample", y = "Reads count") +
  theme(title = element_text(face = "bold.italic", color = "black"), 
        axis.title = element_text(face = "bold.italic", color = "black"), 
        axis.text = element_text(face = "bold"),
        axis.text.x = element_text(angle = 70, hjust = 1, size = 3))




ggplot(merged_data , aes(x = id, y = gdT_mean)) +
    geom_boxplot() +
  theme_bw()+
  labs(title = "Boxplot of cell count of TRD/G genes (RNAseq) by sample", x = "sample", y = "log2(tpm + 1)") +
  theme(title = element_text(face = "bold.italic", color = "black"), 
        axis.title = element_text(face = "bold.italic", color = "black"), 
        axis.text = element_text(face = "bold"),
        axis.text.x = element_text(angle = 70, hjust = 1, size = 3))






# Compute correlation between gdT_mean and log(readsC)
cor_value <- cor(merged_data2$gdT_mean, log(merged_data2$readsC))

# Plot
ggplot(merged_data2, aes(x = gdT_mean, y = log(readsC))) +
  geom_point(color = "blue", size = 3, alpha = 0.5) +  # Add points with color and transparency
  geom_smooth(method = "lm", color = "red", se = TRUE) +    # Add a linear trend line
  labs(
    title = "Relationship between TRUST4 and gdT \n gene expression in COAD",    # Add title
    x = "gdT gene expression",                                               # X-axis label
    y = "Log(TRUST4 read counts)"                                      # Y-axis label
  ) +
  annotate("text", x = Inf, y = Inf, label = paste("Correlation:", round(cor_value, 2)), 
           hjust = 1.6, vjust = 2, size = 5, color = "black") +   # Add correlation score to the plot
  theme_minimal() +                                           # Use a clean theme
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),  # Center and style the title
    axis.title = element_text(size = 12),                              # Increase axis title font size
    axis.text = element_text(size = 10)                                # Increase axis text font size
  )



```



### Read in and merge all of the trust4 files for LAML
```{r, eval = FALSE}
# Set the folder path where your .tsv files are located
folder_path <- "TRUST4/LAML"

# List all .tsv files in the folder
file_list <- list.files(path = folder_path, pattern = "*.tsv", full.names = TRUE)

read_and_add_id <- function(file_path) {
  # Extract the file name without extension
  file_name <- basename(file_path)
  file_name_no_ext <- gsub("\\.tsv$", "", file_name)
  
  # Extract the id (portion before the first underscore)
  id <- unlist(strsplit(file_name_no_ext, "_"))[1]
  
  # Read the .tsv file, setting all columns as characters to avoid type conflicts
  data <- read_tsv(file_path, col_types = cols(.default = "c"))
  
  # Add the 'id' column
  data$id <- id
  
  return(data)
}

# Apply the function to all .tsv files and combine them into one dataframe
T4_data <- lapply(file_list, read_and_add_id) %>%
  bind_rows()

T4_data$gene <- gsub("\\*.*","", T4_data$V)
T4_data$type <- ifelse(grepl("TRA|TRB", T4_data$gene), "abT", "gdT") 
T4_data$count <- as.numeric(T4_data$`#count`)

# count the number of reads by type 
jT_count <- T4_data %>% group_by(type,id) %>%
  summarise(readsC = sum(count), .groups='drop') 
# add meta data

count <- jT_count %>% filter(type == "gdT")





df_tcga_coad <- df_tcga %>%
  filter(id %in% T4_data$id) %>%
  select(id, TRDC, TRGC1, TRGC2) %>%
  mutate(gdT = TRDC + TRGC1 + TRGC2) %>%
  mutate(gdT_mean = rowMeans(select(., TRDC, TRGC1, TRGC2), na.rm = TRUE))
  
#iterate over T4_data, for each sample calculate the sum of the gdT genes

merged_data <- merge(df_tcga_coad, T4_data, by = "id")

merged_data2 <- merge(df_tcga_coad, count, by = "id")

#now do the same one for the amount of gdT genes in each. hmm not sure this is a fair comparison would want to sum over all of the gdT
ggplot(merged_data  %>% filter(grepl("TRD|TRG", gene)), aes(x = id, y = log(count))) +
    geom_boxplot() +
  theme_bw()+
  labs(title = "Boxplot of cell count of TRD/G genes (TRUST4) by sample", x = "sample", y = "Reads count") +
  theme(title = element_text(face = "bold.italic", color = "black"), 
        axis.title = element_text(face = "bold.italic", color = "black"), 
        axis.text = element_text(face = "bold"),
        axis.text.x = element_text(angle = 70, hjust = 1, size = 3))




ggplot(merged_data , aes(x = id, y = gdT_mean)) +
    geom_boxplot() +
  theme_bw()+
  labs(title = "Boxplot of cell count of TRD/G genes (RNAseq) by sample", x = "sample", y = "log2(tpm + 1)") +
  theme(title = element_text(face = "bold.italic", color = "black"), 
        axis.title = element_text(face = "bold.italic", color = "black"), 
        axis.text = element_text(face = "bold"),
        axis.text.x = element_text(angle = 70, hjust = 1, size = 3))






# Compute correlation between gdT_mean and log(readsC)
cor_value <- cor(merged_data2$gdT_mean, log(merged_data2$readsC))

# Plot
ggplot(merged_data2, aes(x = gdT_mean, y = log(readsC))) +
  geom_point(color = "blue", size = 3, alpha = 0.5) +  # Add points with color and transparency
  geom_smooth(method = "lm", color = "red", se = TRUE) +    # Add a linear trend line
  labs(
    title = "Relationship between TRUST4 and gdT \n gene expression in LAML",    # Add title
    x = "gdT gene expression",                                               # X-axis label
    y = "Log(TRUST4 read counts)"                                      # Y-axis label
  ) +
  annotate("text", x = Inf, y = Inf, label = paste("Correlation:", round(cor_value, 2)), 
           hjust = 1.6, vjust = 2, size = 5, color = "black") +   # Add correlation score to the plot
  theme_minimal() +                                           # Use a clean theme
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),  # Center and style the title
    axis.title = element_text(size = 12),                              # Increase axis title font size
    axis.text = element_text(size = 10)                                # Increase axis text font size
  )



```


## Reproducibility token

::: {.callout-caution collapse="true"}
### Expand to see R and packages versions

```{r session-info}
xfun::session_info()
```
:::

